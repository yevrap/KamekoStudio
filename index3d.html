<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Interactive Landing Page - Multi-Portal (Mobile)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', Arial, sans-serif;
            background-color: #111;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overscroll-behavior: none; /* Prevent pull-to-refresh/overscroll effects */
        }
        #scene-container {
            width: 100%;
            height: 100%;
            position: relative;
            transition: filter 0.3s ease-out; /* For blur effect */
        }
        canvas {
            display: block;
        }
        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px; /* Reduced padding for mobile */
            background-color: rgba(0, 0, 0, 0.92);
            border: 1px solid #00aaff;
            border-radius: 10px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
            max-height: 85vh; /* Adjusted max height */
            overflow-y: auto;
        }
        #menu {
            display: none;
            width: 90%; /* Use percentage for mobile */
            max-width: 380px; /* Max width for larger screens */
        }
        #menu h2 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #00aaff;
            font-size: 1.8em; /* Adjusted font size */
            text-shadow: 0 0 6px #00aaff;
        }
        #menu p {
            color: #ddd;
            font-size: 1em; /* Adjusted font size */
            line-height: 1.5;
            margin-bottom: 20px;
        }
        #menu .portal-links-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        #menu a.portal-link {
            display: block;
            padding: 10px 15px; /* Adjusted padding */
            background-color: #0077cc;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.2s;
            font-size: 1em; /* Adjusted font size */
            border: 1px solid #0055aa;
        }
        #menu a.portal-link:hover, #menu a.portal-link:active {
            background-color: #0055aa;
            transform: scale(1.02);
        }
        #menu .close-button-container {
            margin-top: 15px;
        }
        #menu .close-button {
            display: inline-block;
            padding: 10px 20px; /* Adjusted padding */
            background-color: #666;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            font-size: 1em; /* Adjusted font size */
            border: 1px solid #444;
        }
        #menu .close-button:hover, #menu .close-button:active {
            background-color: #444;
            transform: scale(1.02);
        }
        #interaction-prompt {
            display: none;
            position: absolute;
            bottom: 80px; /* Higher to avoid on-screen controls */
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 15px;
            background-color: rgba(0, 85, 170, 0.85);
            border-radius: 8px;
            font-size: 0.9em;
            color: #e0e0e0;
            border: 1px solid #00aaff;
            box-shadow: 0 0 8px rgba(0, 170, 255, 0.4);
            z-index: 5; /* Above canvas, below menu */
        }
        #controls-info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 6px;
            font-size: 0.75em;
            line-height: 1.5;
            border: 1px solid #333;
            z-index: 5;
        }

        /* On-screen controls */
        .touch-controls-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            z-index: 5;
            opacity: 0.7;
        }
        #joystick-base {
            width: 100%;
            height: 100%;
            background-color: rgba(80, 80, 80, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #joystick-handle {
            width: 50px;
            height: 50px;
            background-color: rgba(120, 120, 120, 0.8);
            border-radius: 50%;
            border: 2px solid rgba(200,200,200,0.7);
        }
        #interact-button-touch {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 70px;
            height: 70px;
            background-color: rgba(0, 122, 204, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            color: white;
            border: 2px solid rgba(0,170,255,0.9);
            z-index: 5;
            opacity: 0.8;
            user-select: none; /* Prevent text selection on tap */
        }
        #interact-button-touch:active {
            background-color: rgba(0, 85, 170, 0.9);
            transform: scale(0.95);
        }


        /* Scrollbar styling */
        .overlay::-webkit-scrollbar { width: 8px; }
        .overlay::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 10px; }
        .overlay::-webkit-scrollbar-thumb { background-color: #0077cc; border-radius: 10px; border: 2px solid rgba(0,0,0,0.3); }
        .overlay::-webkit-scrollbar-thumb:hover { background-color: #0055aa; }

        /* Hide keyboard controls info on small screens by default */
        @media (max-width: 768px) {
            #controls-info {
                display: none;
            }
            #interaction-prompt {
                font-size: 0.8em;
                padding: 8px 12px;
                bottom: 90px; /* Adjust if overlapping with interact button */
            }
        }
        /* Show touch controls only on touch devices (simplistic check) */
        .touch-controls-container, #interact-button-touch {
            display: none; /* Hidden by default, shown by JS if touch is detected */
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<div id="scene-container">
</div>

<div id="menu" class="overlay">
    <h2>Dimensional Gateway Matrix</h2>
    <p>The Gateway is active. Select a dimension to explore, or remain in this nexus.</p>
    <div class="portal-links-container">
        <a href="https://yevrap.github.io/KamekoStudio/" target="_blank" class="portal-link">Kameko Studio (Main Hub)</a>
        <a href="games/hiddenObject.html" target="_blank" class="portal-link">Hidden Object Realm</a>
        <a href="games/memoryTower.html" target="_blank" class="portal-link">Memory Tower Citadel</a>
        <a href="games/riverRun.html" target="_blank" class="portal-link">River Run Rapids</a>
        <a href="games/blobZapper.html" target="_blank" class="portal-link">Blob Zapper Arena</a>
        <a href="games/materialsRun.html" target="_blank" class="portal-link">Materials Run Expanse</a>
    </div>
    <div class="close-button-container">
        <div class="close-button" onclick="hideMenu()">Remain in Nexus</div>
    </div>
</div>

<div id="interaction-prompt">
</div>

<div id="controls-info">
    <strong>Controls (Keyboard):</strong><br>
    W/S or Up/Down: Move<br>
    A/D or Left/Right: Strafe<br>
    Mouse: Look Around<br>
    E: Interact with Gateway
</div>

<div class="touch-controls-container" id="joystick-container">
    <div id="joystick-base">
        <div id="joystick-handle"></div>
    </div>
</div>
<div id="interact-button-touch">ACT</div>


<script>
    // --- Global Variables ---
    let scene, camera, renderer;
    let player, playerVelocity; // playerRotationSpeed removed, handled by look controls
    let keysPressed = {};
    const playerHeight = 1.8;
    const playerSpeed = 4.0; // Slightly reduced speed for easier touch control
    const playerRadius = 0.4;
    let walls = [];
    let menuActivatorMesh;
    const interactionDistance = 2.5;
    let canInteract = false;
    let menuOpen = false;

    const menuElement = document.getElementById('menu');
    const interactionPromptElement = document.getElementById('interaction-prompt');
    const sceneContainer = document.getElementById('scene-container');
    const joystickContainer = document.getElementById('joystick-container');
    const joystickBase = document.getElementById('joystick-base');
    const joystickHandle = document.getElementById('joystick-handle');
    const interactButtonTouch = document.getElementById('interact-button-touch');

    const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
    let touchLookStartX, touchLookStartY, currentLookTouchId;
    let joystickActive = false;
    let joystickStartX, joystickStartY, currentJoystickTouchId;
    let joystickInput = { x: 0, y: 0 }; // y for forward/backward, x for strafe
    const joystickMaxDistance = joystickBase.offsetWidth / 3; // Max travel for handle

    // --- Initialization ---
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 12, 35);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, playerHeight, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        sceneContainer.appendChild(renderer.domElement);

        player = new THREE.Group();
        player.position.set(0, 0, 5);
        player.add(camera);
        scene.add(player);

        playerVelocity = new THREE.Vector3();

        const ambientLight = new THREE.AmbientLight(0x708090, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xe0e0ff, 1.0);
        directionalLight.position.set(10, 18, 12);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 60;
        scene.add(directionalLight);

        createEnvironment();
        setupControls();

        animate();
    }

    // --- Environment Creation (Simplified from previous) ---
    function createEnvironment() {
        const roomWidth = 18; const roomDepth = 24; const roomHeight = 6; const wallThickness = 0.5;
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x455A64, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), floorMaterial);
        floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x607D8B, roughness: 0.7, metalness: 0.1 });
        function createWall(w, h, d, x, y, z) {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMaterial);
            wall.position.set(x,y,z); wall.castShadow = true; wall.receiveShadow = true; scene.add(wall); walls.push(new THREE.Box3().setFromObject(wall));
        }
        createWall(roomWidth + wallThickness, roomHeight, wallThickness, 0, roomHeight/2, -roomDepth/2);
        createWall(roomWidth + wallThickness, roomHeight, wallThickness, 0, roomHeight/2, roomDepth/2);
        createWall(wallThickness, roomHeight, roomDepth, -roomWidth/2, roomHeight/2, 0);
        createWall(wallThickness, roomHeight, roomDepth, roomWidth/2, roomHeight/2, 0);
        const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x546E7A, side: THREE.DoubleSide, roughness: 0.9 });
        const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), ceilingMaterial);
        ceiling.position.y = roomHeight; ceiling.rotation.x = Math.PI / 2; scene.add(ceiling);
        const activatorGeometry = new THREE.OctahedronGeometry(0.7, 0);
        const activatorMaterial = new THREE.MeshStandardMaterial({ color: 0x00ccff, emissive: 0x0077aa, metalness: 0.4, roughness: 0.3, transparent: true, opacity: 0.85 });
        menuActivatorMesh = new THREE.Mesh(activatorGeometry, activatorMaterial);
        menuActivatorMesh.position.set(0, 1.0, -roomDepth/2 + wallThickness + 1.2); menuActivatorMesh.castShadow = true; scene.add(menuActivatorMesh);
        const activatorLight = new THREE.PointLight(0x00ccff, 1, 7);
        activatorLight.position.copy(menuActivatorMesh.position); activatorLight.position.y += 0.2; scene.add(activatorLight);
    }

    // --- Controls Setup ---
    function setupControls() {
        if (isTouchDevice) {
            joystickContainer.style.display = 'block';
            interactButtonTouch.style.display = 'flex';
            document.getElementById('controls-info').style.display = 'none'; // Hide keyboard info

            // Joystick listeners
            joystickBase.addEventListener('touchstart', handleJoystickStart, { passive: false });
            joystickBase.addEventListener('touchmove', handleJoystickMove, { passive: false });
            joystickBase.addEventListener('touchend', handleJoystickEnd, { passive: false });
            joystickBase.addEventListener('touchcancel', handleJoystickEnd, { passive: false });

            // Look listeners (on the main scene)
            sceneContainer.addEventListener('touchstart', handleLookStart, { passive: false });
            sceneContainer.addEventListener('touchmove', handleLookMove, { passive: false });
            sceneContainer.addEventListener('touchend', handleLookEnd, { passive: false });

            // Interact button listener
            interactButtonTouch.addEventListener('click', () => { // Using click for simplicity, works for touch too
                if (canInteract && !menuOpen) showMenu();
            });
            interactionPromptElement.textContent = "Tap ACT to activate Gateway";


        } else { // Desktop controls
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            renderer.domElement.addEventListener('click', () => {
                if (!document.pointerLockElement && !menuOpen) renderer.domElement.requestPointerLock();
            });
            interactionPromptElement.textContent = "Press 'E' to activate Gateway";
        }
        window.addEventListener('resize', onWindowResize);
    }

    // --- Touch Joystick Handlers ---
    function handleJoystickStart(event) {
        event.preventDefault();
        if (menuOpen) return;
        joystickActive = true;
        const touch = event.changedTouches[0];
        currentJoystickTouchId = touch.identifier;
        const rect = joystickBase.getBoundingClientRect();
        joystickStartX = touch.clientX - rect.left - rect.width / 2;
        joystickStartY = touch.clientY - rect.top - rect.height / 2;
        joystickHandle.style.transform = `translate(${joystickStartX}px, ${joystickStartY}px)`;
    }

    function handleJoystickMove(event) {
        event.preventDefault();
        if (!joystickActive || menuOpen) return;
        let touch = null;
        for(let i=0; i < event.changedTouches.length; i++){
            if(event.changedTouches[i].identifier === currentJoystickTouchId){
                touch = event.changedTouches[i];
                break;
            }
        }
        if(!touch) return;

        const rect = joystickBase.getBoundingClientRect();
        let moveX = touch.clientX - rect.left - rect.width / 2;
        let moveY = touch.clientY - rect.top - rect.height / 2;

        const distance = Math.sqrt(moveX * moveX + moveY * moveY);
        if (distance > joystickMaxDistance) {
            moveX = (moveX / distance) * joystickMaxDistance;
            moveY = (moveY / distance) * joystickMaxDistance;
        }
        joystickHandle.style.transform = `translate(${moveX}px, ${moveY}px)`;
        joystickInput.x = moveX / joystickMaxDistance;
        joystickInput.y = -moveY / joystickMaxDistance; // Invert Y for forward
    }

    function handleJoystickEnd(event) {
        let touchReleased = false;
        for(let i=0; i < event.changedTouches.length; i++){
            if(event.changedTouches[i].identifier === currentJoystickTouchId){
                touchReleased = true;
                break;
            }
        }
        if (!joystickActive || !touchReleased) return;

        joystickActive = false;
        currentJoystickTouchId = null;
        joystickHandle.style.transform = `translate(0px, 0px)`;
        joystickInput.x = 0;
        joystickInput.y = 0;
    }

    // --- Touch Look Handlers ---
    function handleLookStart(event) {
        // Prevent look if touch starts on UI elements
        if (menuOpen || event.target !== renderer.domElement) return;
        event.preventDefault();
        const touch = event.changedTouches[0];
        currentLookTouchId = touch.identifier;
        touchLookStartX = touch.clientX;
        touchLookStartY = touch.clientY;
    }

    function handleLookMove(event) {
        if (menuOpen || currentLookTouchId === null || event.target !== renderer.domElement) return;
        event.preventDefault();
        let touch = null;
        for(let i=0; i < event.changedTouches.length; i++){
            if(event.changedTouches[i].identifier === currentLookTouchId){
                touch = event.changedTouches[i];
                break;
            }
        }
        if(!touch) return;

        const deltaX = touch.clientX - touchLookStartX;
        const deltaY = touch.clientY - touchLookStartY;

        player.rotation.y -= deltaX * 0.005; // Adjust sensitivity as needed
        camera.rotation.x -= deltaY * 0.005;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

        touchLookStartX = touch.clientX;
        touchLookStartY = touch.clientY;
    }

    function handleLookEnd(event) {
        if (currentLookTouchId === null) return;
        let touchReleased = false;
        for(let i=0; i < event.changedTouches.length; i++){
            if(event.changedTouches[i].identifier === currentLookTouchId){
                touchReleased = true;
                break;
            }
        }
        if(!touchReleased) return;
        currentLookTouchId = null;
    }


    // --- Keyboard Event Handlers (Desktop) ---
    function onKeyDown(event) {
        keysPressed[event.key.toLowerCase()] = true;
        if (event.key.toLowerCase() === 'e' && canInteract && !menuOpen) {
            showMenu();
        } else if (event.key.toLowerCase() === 'escape') {
            if (menuOpen) hideMenu();
            else if (document.pointerLockElement) document.exitPointerLock();
        }
    }
    function onKeyUp(event) { keysPressed[event.key.toLowerCase()] = false; }

    let isPointerLocked = false;
    function onPointerLockChange() {
        if (document.pointerLockElement === renderer.domElement) {
            document.addEventListener("mousemove", onMouseMove, false);
            isPointerLocked = true;
        } else {
            document.removeEventListener("mousemove", onMouseMove, false);
            isPointerLocked = false;
        }
    }
    function onMouseMove(event) { // Only for desktop pointer lock
        if (!isPointerLocked || menuOpen) return;
        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;
        player.rotation.y -= movementX * 0.002;
        camera.rotation.x -= movementY * 0.002;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- Game Logic Update ---
    const clock = new THREE.Clock();
    let time = 0;

    function updatePlayer(deltaTime) {
        if (menuOpen) {
            joystickInput.x = 0; joystickInput.y = 0; // Stop joystick movement if menu opens
            keysPressed = {}; // Clear keyboard input too
            return;
        }

        const moveSpeed = playerSpeed * deltaTime;
        let moveDirection = new THREE.Vector3();

        // Keyboard input
        if (keysPressed['w'] || keysPressed['arrowup']) moveDirection.z = -1;
        if (keysPressed['s'] || keysPressed['arrowdown']) moveDirection.z = 1;
        if (keysPressed['a'] || keysPressed['arrowleft']) moveDirection.x = -1;
        if (keysPressed['d'] || keysPressed['arrowright']) moveDirection.x = 1;

        // Touch joystick input (overrides or adds to keyboard)
        if (joystickInput.y !== 0) moveDirection.z = joystickInput.y;
        if (joystickInput.x !== 0) moveDirection.x = joystickInput.x;

        if (moveDirection.lengthSq() > 0) moveDirection.normalize();

        const worldMoveDelta = moveDirection.clone().multiplyScalar(moveSpeed).applyEuler(player.rotation);
        const nextPosition = player.position.clone().add(worldMoveDelta);

        const playerCollider = new THREE.Box3(
            new THREE.Vector3(nextPosition.x - playerRadius, nextPosition.y, nextPosition.z - playerRadius),
            new THREE.Vector3(nextPosition.x + playerRadius, nextPosition.y + playerHeight, nextPosition.z + playerRadius)
        );

        let collision = false;
        for (const wallBox of walls) { if (playerCollider.intersectsBox(wallBox)) { collision = true; break; } }

        if (!collision) {
            player.position.copy(nextPosition);
        } else {
            let tempPos = player.position.clone(); tempPos.x += worldMoveDelta.x;
            let playerColliderX = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(tempPos.x, tempPos.y + playerHeight / 2, player.position.z), new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2));
            let collisionX = false; for (const wallBox of walls) { if (playerColliderX.intersectsBox(wallBox)) { collisionX = true; break; } }
            if(!collisionX) player.position.x = tempPos.x;

            tempPos = player.position.clone(); tempPos.z += worldMoveDelta.z;
            let playerColliderZ = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(player.position.x, tempPos.y + playerHeight / 2, tempPos.z), new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2));
            let collisionZ = false; for (const wallBox of walls) { if (playerColliderZ.intersectsBox(wallBox)) { collisionZ = true; break; } }
            if(!collisionZ) player.position.z = tempPos.z;
        }

        const distanceToActivator = player.position.distanceTo(menuActivatorMesh.position);
        if (distanceToActivator < interactionDistance && !menuOpen) {
            canInteract = true;
            interactionPromptElement.style.display = 'block';
        } else {
            canInteract = false;
            interactionPromptElement.style.display = 'none';
        }

        if (menuActivatorMesh) {
            time += deltaTime;
            menuActivatorMesh.rotation.y = time * 0.5;
            menuActivatorMesh.position.y = 1.0 + Math.sin(time * 1.5) * 0.1;
        }
    }

    // --- Menu Functions ---
    function showMenu() {
        menuElement.style.display = 'block';
        menuOpen = true;
        interactionPromptElement.style.display = 'none';
        if (!isTouchDevice && document.pointerLockElement) document.exitPointerLock();
        sceneContainer.style.filter = 'blur(4px)'; // Slightly less blur for mobile performance
    }

    function hideMenu() {
        menuElement.style.display = 'none';
        menuOpen = false;
        sceneContainer.style.filter = 'none';
    }

    // --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();
        updatePlayer(deltaTime);
        renderer.render(scene, camera);
    }

    init(); // Start
</script>
</body>
</html>
