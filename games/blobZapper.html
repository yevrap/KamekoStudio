<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lava Plasma Flow - Destruction</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; background-color: #1a1a2e; font-family: 'Inter', sans-serif; color: white; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; background-color: #0f0f1a; max-width: 100vw; max-height: 100vh; box-shadow: 0 0 15px rgba(0,0,0,0.5); border-radius: 8px; }
        .overlay { position: absolute; left: 50%; transform: translateX(-50%); color: rgba(255, 255, 255, 0.8); text-shadow: 0 0 5px rgba(0, 0, 0, 0.5); pointer-events: none; text-align: center; z-index: 10; width: 80%; }
        .title-overlay { top: 15px; font-size: calc(0.8rem + 0.5vmin); }
        #pushBtn { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 25px; font-size: 1rem; font-weight: bold; color: white; background-color: #6272a4; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); transition: background-color 0.2s ease, transform 0.1s ease; z-index: 5; }
        #pushBtn:hover { background-color: #7a8ac4; }
        #pushBtn:active { background-color: #505d8a; transform: translateX(-50%) scale(0.98); }
        body[data-game-over="true"] #pushBtn { display: none; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="overlay title-overlay">Lava Plasma Flow - Clear the Blobs!</div>
    <canvas id="gameCanvas"></canvas>
    <button id="pushBtn">Push Blobs</button>

    <script>
        console.log("Script start");

        // Wrap main logic in DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing script...");

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            // Get button reference *after* DOM is loaded
            const pushButton = document.getElementById('pushBtn');

            if (!ctx) {
                console.error("Fatal Error: Failed to get 2D context for canvas.");
                const errorDiv = document.createElement('div');
                errorDiv.textContent = "Error: Could not initialize graphics.";
                errorDiv.style.cssText = "color:red; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);";
                document.body.appendChild(errorDiv);
                return; // Stop script if context fails
            }
            // Check if button exists
            if (!pushButton) {
                 console.error("Fatal Error: Could not find push button element.");
                 return; // Stop script if button not found
            }

            console.log("Canvas context and button obtained successfully.");

            // --- Configuration (Simplified Sizes) ---
            const NUM_BLOBS_START = 5;
            const MIN_BLOB_RADIUS = 10;
            const MAX_BLOB_RADIUS = 30;
            const BLOB_SPEED = 0.3;
            const TOUCH_REPULSION_FORCE = 2.0;
            const TOUCH_REPULSION_RADIUS = 150;
            const TENDRIL_MAX_DIST = 200;
            const TENDRIL_COLOR = 'rgba(192, 132, 252, 0.6)';
            const BLOB_COLORS = [
                'rgba(236, 72, 153, 0.7)', 'rgba(168, 85, 247, 0.7)', 'rgba(99, 102, 241, 0.7)',
                'rgba(59, 130, 246, 0.7)', 'rgba(34, 197, 94, 0.7)'
            ];
            const DESTRUCTION_ZONE_RADIUS = 60;
            const DESTRUCTION_ZONE_COLOR_FILL = 'rgba(255, 50, 50, 0.2)';
            const DESTRUCTION_ZONE_COLOR_STROKE = 'rgba(255, 80, 80, 0.8)';
            const DESTRUCTION_ZONE_SPEED = 0.5;
            const BUTTON_PUSH_IMPULSE = 4;

            let blobs = [];
            let touchPoints = [];
            let destructionZone = { x: 0, y: 0, radius: DESTRUCTION_ZONE_RADIUS, vx: 0, vy: 0 };

            let isGameOver = false;
            let animationFrameId;
            let lastTime = 0;

            // --- Blob Class ---
            class Blob {
                 constructor(x, y, radius, color) {
                    this.x = x; this.y = y; this.radius = radius; this.color = color;
                    this.vx = (Math.random() - 0.5) * BLOB_SPEED * 2;
                    this.vy = (Math.random() - 0.5) * BLOB_SPEED * 2;
                }
                update(deltaTime) {
                    try {
                        this.x += this.vx * deltaTime; this.y += this.vy * deltaTime;
                        // Boundary Collision
                        if (this.x - this.radius < 0) { this.x = this.radius; this.vx *= -0.8; }
                        else if (this.x + this.radius > canvas.width) { this.x = canvas.width - this.radius; this.vx *= -0.8; }
                        if (this.y - this.radius < 0) { this.y = this.radius; this.vy *= -0.8; }
                        else if (this.y + this.radius > canvas.height) { this.y = canvas.height - this.radius; this.vy *= -0.8; }
                        // Touch Repulsion
                        touchPoints.forEach(touch => {
                            const dx = this.x - touch.x; const dy = this.y - touch.y;
                            const distSq = dx * dx + dy * dy;
                            const repulsionRadiusSq = TOUCH_REPULSION_RADIUS * TOUCH_REPULSION_RADIUS;
                            if (distSq < repulsionRadiusSq && distSq > 1) {
                                const dist = Math.sqrt(distSq);
                                const force = (1 - dist / TOUCH_REPULSION_RADIUS) * TOUCH_REPULSION_FORCE;
                                const forceMultiplier = deltaTime / Math.max(1, this.radius / MIN_BLOB_RADIUS);
                                this.vx += (dx / dist) * force * forceMultiplier;
                                this.vy += (dy / dist) * force * forceMultiplier;
                            }
                        });
                        // Dampen & Wiggle
                        this.vx *= 0.995; this.vy *= 0.995;
                        this.vx += (Math.random() - 0.5) * BLOB_SPEED * 0.1 * deltaTime;
                        this.vy += (Math.random() - 0.5) * BLOB_SPEED * 0.1 * deltaTime;
                    } catch (error) { console.error("Error during Blob update:", error); }
                }
                draw() {
                     try {
                        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fillStyle = this.color; ctx.fill();
                    } catch (error) { console.error("Error during Blob draw:", error); }
                }
            }


            // --- Initialization ---
            function init() {
                console.log("Initializing game...");
                try {
                    resizeCanvas();
                    isGameOver = false;
                    document.body.dataset.gameOver = "false";
                    blobs = [];
                    touchPoints = [];

                    destructionZone.vx = (Math.random() - 0.5) * DESTRUCTION_ZONE_SPEED * 2;
                    destructionZone.vy = (Math.random() - 0.5) * DESTRUCTION_ZONE_SPEED * 2;

                    for (let i = 0; i < NUM_BLOBS_START; i++) {
                        const radius = MIN_BLOB_RADIUS + Math.random() * (MAX_BLOB_RADIUS - MIN_BLOB_RADIUS);
                        if (canvas.width > radius * 2 && canvas.height > radius * 2) {
                            const x = radius + Math.random() * (canvas.width - radius * 2);
                            const y = radius + Math.random() * (canvas.height - radius * 2);
                            const color = BLOB_COLORS[Math.floor(Math.random() * BLOB_COLORS.length)];
                            if (!isNaN(x) && !isNaN(y) && !isNaN(radius) && radius > 0) {
                                 blobs.push(new Blob(x, y, radius, color));
                            } else { console.warn("Skipped creating blob due to invalid calculated values"); }
                        } else { console.warn("Canvas too small to create blobs"); break; }
                    }
                    console.log(`Created ${blobs.length} blobs.`);

                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    lastTime = performance.now();
                    animate();
                    console.log("Initialization complete. Animation started.");
                } catch (error) { console.error("Error during init:", error); }
            }

            // --- Canvas Resizing (Simplified) ---
            function resizeCanvas() {
                console.log("Resizing canvas (Simplified)...");
                try {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    // Update destruction zone radius
                    destructionZone.radius = Math.max(30, Math.min(canvas.width, canvas.height) * 0.1);

                    // Center zone or keep it within bounds
                    if (!destructionZone.x || destructionZone.x === 0 || isNaN(destructionZone.x)) {
                         destructionZone.x = canvas.width / 2;
                         destructionZone.y = canvas.height / 2;
                    } else {
                         destructionZone.x = Math.max(destructionZone.radius, Math.min(canvas.width - destructionZone.radius, destructionZone.x));
                         destructionZone.y = Math.max(destructionZone.radius, Math.min(canvas.height - destructionZone.radius, destructionZone.y));
                    }
                    console.log(`Canvas resized to ${canvas.width}x${canvas.height}. Zone radius: ${destructionZone.radius}`);
                } catch (error) { console.error("Error during resizeCanvas:", error); }
            }

            // --- Update Destruction Zone ---
            function updateDestructionZone(deltaTime) {
                 destructionZone.vx = isNaN(destructionZone.vx) ? 0 : destructionZone.vx;
                 destructionZone.vy = isNaN(destructionZone.vy) ? 0 : destructionZone.vy;
                 destructionZone.x = isNaN(destructionZone.x) ? canvas.width / 2 : destructionZone.x;
                 destructionZone.y = isNaN(destructionZone.y) ? canvas.height / 2 : destructionZone.y;
                 destructionZone.x += destructionZone.vx * deltaTime;
                 destructionZone.y += destructionZone.vy * deltaTime;
                 // Boundary Collision & Direction Change (logic remains same)
                  if (destructionZone.x - destructionZone.radius < 0) { destructionZone.x = destructionZone.radius; destructionZone.vx *= -1; }
                 else if (destructionZone.x + destructionZone.radius > canvas.width) { destructionZone.x = canvas.width - destructionZone.radius; destructionZone.vx *= -1; }
                 if (destructionZone.y - destructionZone.radius < 0) { destructionZone.y = destructionZone.radius; destructionZone.vy *= -1; }
                 else if (destructionZone.y + destructionZone.radius > canvas.height) { destructionZone.y = canvas.height - destructionZone.radius; destructionZone.vy *= -1; }
                 if (Math.random() < 0.015) {
                      const speedFactor = DESTRUCTION_ZONE_SPEED;
                      destructionZone.vx += (Math.random() - 0.5) * speedFactor * 0.6;
                      destructionZone.vy += (Math.random() - 0.5) * speedFactor * 0.6;
                      const speed = Math.sqrt(destructionZone.vx * destructionZone.vx + destructionZone.vy * destructionZone.vy);
                      const maxSpeed = speedFactor * 1.5;
                      if (speed > maxSpeed) { destructionZone.vx = (destructionZone.vx / speed) * maxSpeed; destructionZone.vy = (destructionZone.vy / speed) * maxSpeed; }
                      const minSpeed = speedFactor * 0.5;
                      if (speed < minSpeed && speed > 0) { destructionZone.vx = (destructionZone.vx / speed) * minSpeed; destructionZone.vy = (destructionZone.vy / speed) * minSpeed; }
                      else if (speed === 0) { destructionZone.vx = (Math.random() - 0.5) * speedFactor; destructionZone.vy = (Math.random() - 0.5) * speedFactor; }
                 }
            }


            // --- Drawing ---
            function drawDestructionZone() {
                try {
                    const pulse = Math.sin(performance.now() * 0.003) * 3 + 3;
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.fillStyle = DESTRUCTION_ZONE_COLOR_FILL;
                    ctx.beginPath(); ctx.arc(destructionZone.x, destructionZone.y, destructionZone.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = DESTRUCTION_ZONE_COLOR_STROKE; ctx.lineWidth = pulse;
                    ctx.beginPath(); ctx.arc(destructionZone.x, destructionZone.y, destructionZone.radius, 0, Math.PI * 2); ctx.stroke();
                    ctx.lineWidth = 1;
                } catch (error) { console.error("Error drawing destruction zone:", error); }
            }
            function drawTendrils() {
                 try {
                    ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = TENDRIL_COLOR;
                    ctx.lineWidth = 1.5;
                    const maxDist = TENDRIL_MAX_DIST;
                    touchPoints.forEach(touch => {
                        blobs.forEach(blob => {
                            const dx = blob.x - touch.x; const dy = blob.y - touch.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < maxDist && dist > blob.radius * 0.5) {
                                ctx.beginPath(); ctx.moveTo(blob.x, blob.y); ctx.lineTo(touch.x, touch.y); ctx.stroke();
                            }
                        });
                    });
                } catch (error) { console.error("Error drawing tendrils:", error); }
            }
            function drawBlobs() {
                try {
                    ctx.globalCompositeOperation = 'source-over'; // Simplified drawing
                    blobs.forEach(blob => blob.draw());
                } catch (error) { console.error("Error drawing blobs:", error); }
            }
            function drawUI() { // Draw Game Over on Canvas
                 if (isGameOver) {
                    try {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#ff6b6b';
                        const gameOverFontSize = Math.max(24, Math.min(canvas.width * 0.1, 60));
                        ctx.font = `bold ${gameOverFontSize}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - gameOverFontSize * 0.5);
                        const restartFontSize = Math.max(14, Math.min(canvas.width * 0.04, 24));
                        ctx.font = `${restartFontSize}px Inter`;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fillText('Tap to Restart', canvas.width / 2, canvas.height / 2 + gameOverFontSize * 0.5);
                    } catch (error) { console.error("Error drawing game over UI:", error); }
                 }
            }


            // --- Animation Loop ---
            function animate(currentTime = 0) {
                animationFrameId = requestAnimationFrame(animate);
                try {
                    const elapsed = currentTime - lastTime;
                    lastTime = currentTime;
                    let deltaTime = elapsed / (1000 / 60);
                    if (isNaN(deltaTime) || deltaTime <= 0) deltaTime = 1;
                    deltaTime = Math.min(deltaTime, 5);

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // --- DEBUG: Draw Red Square ---
                    try {
                         ctx.fillStyle = 'red';
                         ctx.fillRect(10, 10, 50, 50);
                    } catch(e) { console.error("Error drawing test rect:", e); }
                    // --- END DEBUG ---


                    if (!isGameOver) {
                        updateDestructionZone(deltaTime);

                        for (let i = blobs.length - 1; i >= 0; i--) {
                            const blob = blobs[i];
                            if (!blob) { continue; }
                            blob.update(deltaTime);
                            const dx = blob.x - destructionZone.x; const dy = blob.y - destructionZone.y;
                            const distSq = dx * dx + dy * dy;
                            if (distSq < (destructionZone.radius + blob.radius) * (destructionZone.radius + blob.radius)) {
                                blobs.splice(i, 1);
                            }
                        }

                        if (blobs.length === 0 && NUM_BLOBS_START > 0) {
                             console.log("Game Over condition met.");
                             isGameOver = true;
                             document.body.dataset.gameOver = "true";
                        }

                        drawDestructionZone();
                        drawBlobs();
                        drawTendrils();
                    }

                    drawUI(); // Draw UI last

                } catch (error) {
                    console.error("Error in animation loop:", error);
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                }
            }

            // --- Button Push Logic ---
            function pushBlobsTowardsCenter() {
                if (isGameOver) return;
                console.log("Push button activated");
                blobs.forEach(blob => {
                    const dx = destructionZone.x - blob.x; const dy = destructionZone.y - blob.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > 1) {
                        const dist = Math.sqrt(distSq);
                        const nx = dx / dist; const ny = dy / dist;
                        blob.vx += nx * BUTTON_PUSH_IMPULSE;
                        blob.vy += ny * BUTTON_PUSH_IMPULSE;
                    }
                });
            }


            // --- Event Listeners ---
            window.addEventListener('resize', init);
            // Ensure pushButton exists before adding listener
            if (pushButton) {
                 pushButton.addEventListener('click', pushBlobsTowardsCenter);
                 pushButton.addEventListener('touchstart', (e) => { e.preventDefault(); pushBlobsTowardsCenter(); }, { passive: false });
            } else {
                 console.error("Push button was not found, cannot add listeners.");
            }


            // --- Input Handling ---
             function handlePointerDown(id, clientX, clientY) { /* ... */ }
             function handlePointerMove(id, clientX, clientY) { /* ... */ }
             function handlePointerUp(id) { /* ... */ }
             // --- Input Handling Implementation (Collapsed) ---
            function handlePointerDown(id, clientX, clientY) {
                 if (isGameOver) { init(); return; }
                 try {
                     const rect = canvas.getBoundingClientRect();
                     // Check if rect exists before accessing properties
                     if (!rect) { console.error("Canvas rect not found in handlePointerDown"); return; }
                     const x = clientX - rect.left; const y = clientY - rect.top;
                     if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) return;
                     const existingPoint = touchPoints.find(p => p.id === id);
                     if (!existingPoint) touchPoints.push({ id, x, y });
                     else { existingPoint.x = x; existingPoint.y = y; }
                 } catch (error) { console.error("Error in handlePointerDown:", error); }
            }
            function handlePointerMove(id, clientX, clientY) {
                if (isGameOver) return;
                try {
                    const rect = canvas.getBoundingClientRect();
                    if (!rect) { console.error("Canvas rect not found in handlePointerMove"); return; }
                    const x = clientX - rect.left; const y = clientY - rect.top;
                    if (x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height) {
                         const point = touchPoints.find(p => p.id === id);
                         if (point) { point.x = x; point.y = y; }
                    } else { handlePointerUp(id); }
                } catch (error) { console.error("Error in handlePointerMove:", error); }
            }
            function handlePointerUp(id) {
                if (!isGameOver) {
                     try { touchPoints = touchPoints.filter(p => p.id !== id); }
                     catch (error) { console.error("Error in handlePointerUp:", error); touchPoints = []; }
                }
            }


            // --- Attach Listeners ---
            canvas.addEventListener('mousedown', (e) => { handlePointerDown('mouse', e.clientX, e.clientY); });
            canvas.addEventListener('mousemove', (e) => { if (e.buttons === 1) handlePointerMove('mouse', e.clientX, e.clientY); });
            window.addEventListener('mouseup', () => handlePointerUp('mouse'));
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; handlePointerDown(touch.identifier, touch.clientX, touch.clientY); }
            }, { passive: false });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; handlePointerMove(touch.identifier, touch.clientX, touch.clientY); }
            }, { passive: false });
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!isGameOver) { for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; handlePointerUp(touch.identifier); } }
                else { touchPoints = []; }
            });
             canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                if (!isGameOver) { for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; handlePointerUp(touch.identifier); } }
                else { touchPoints = []; }
            });


            // --- Start ---
            init(); // Initial call

        }); // End of DOMContentLoaded listener

    </script>
</body>
</html>
